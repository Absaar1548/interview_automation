import uuid
from datetime import timedelta, datetime, timezone
from typing import List
from fastapi import APIRouter, HTTPException, status, Depends, Form, UploadFile, File
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
import secrets
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.schemas.auth import TokenResponse, LoginRequest, CandidateResponse
from app.db.sql.session import get_db_session
from app.db.sql.unit_of_work import UnitOfWork
from app.db.sql.models.user import User, CandidateProfile, AdminProfile
from app.db.sql.enums import UserRole
from app.core.security import verify_password, create_access_token, get_password_hash
from app.core.config import settings
from app.services.email_service import email_service

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

def validate_uuid(id_str: str) -> uuid.UUID:
    try:
        return uuid.UUID(id_str)
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=f"Invalid UUID: {id_str}",
        )

async def get_current_user(token: str = Depends(oauth2_scheme), session: AsyncSession = Depends(get_db_session)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id_str: str = payload.get("sub")
        if user_id_str is None:
            raise credentials_exception
            
        try:
            user_id = uuid.UUID(user_id_str)
        except ValueError:
            raise credentials_exception
            
    except JWTError:
        raise credentials_exception
    
    async with UnitOfWork(session) as uow:
        user = await uow.users.get_by_id(user_id)
        if user is None:
            raise credentials_exception
        return user

async def get_current_active_user(current_user: User = Depends(get_current_user)):
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

async def get_current_admin(current_user: User = Depends(get_current_active_user)):
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(status_code=403, detail="The user doesn't have enough privileges")
    return current_user

@router.post("/register/candidate", response_model=TokenResponse)
async def register_candidate(user_data: dict, session: AsyncSession = Depends(get_db_session)):
    """Warning: mock route. Uses direct dictionary rather than Pydantic struct to bypass typing logic conflicts temporarily during migration."""
    raise HTTPException(status_code=501, detail="Direct unauthenticated registration is intentionally disabled. Admins must provision candidates natively.")

@router.post("/login/admin", response_model=TokenResponse)
async def login_admin(request: LoginRequest, session: AsyncSession = Depends(get_db_session)):
    async with UnitOfWork(session) as uow:
        user = await uow.users.get_by_username(request.username)
        
        if not user or not verify_password(request.password, user.hashed_password):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect admin credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        if user.role != UserRole.ADMIN:
             raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User is not an admin",
            )
    
        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            subject=str(user.id), expires_delta=access_token_expires
        )
    
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "username": user.username,
            "role": user.role.value
        }

@router.post("/login/candidate", response_model=TokenResponse)
async def login_candidate(request: LoginRequest, session: AsyncSession = Depends(get_db_session)):
    async with UnitOfWork(session) as uow:
        user = await uow.users.get_by_username(request.username)
        
        if not user or not verify_password(request.password, user.hashed_password):
             raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect candidate credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        if user.role != UserRole.CANDIDATE:
             raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User is not a candidate",
            )
            
        if user.login_disabled:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Login has been disabled for this account. Please contact the administrator."
            )
    
        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            subject=str(user.id), expires_delta=access_token_expires
        )
    
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "username": user.username,
            "role": user.role.value
        }

@router.get("/me")
async def read_users_me(current_user: User = Depends(get_current_active_user)):
    return {
        "id": str(current_user.id),
        "username": current_user.username,
        "email": current_user.email,
        "role": current_user.role.value,
        "is_active": current_user.is_active,
    }

@router.post("/logout")
async def logout():
    return {"message": "Successfully logged out"}

# --- Admin Features ---

@router.post("/admin/register-candidate", response_model=CandidateResponse, status_code=status.HTTP_201_CREATED)
async def admin_register_candidate(
    candidate_name: str = Form(...),
    candidate_email: str = Form(...),
    job_description: str = Form(...),
    resume: UploadFile = File(...),
    current_admin: User = Depends(get_current_admin),
    session: AsyncSession = Depends(get_db_session)
):
    async with UnitOfWork(session) as uow:
        username = candidate_email.split('@')[0]
        
        existing_user = await uow.users.get_by_username(username)
        if existing_user:
             raise HTTPException(status_code=400, detail="Candidate with this email/username already exists")
    
        password = secrets.token_urlsafe(12)
        hashed_password = get_password_hash(password)
        
        resume_id = secrets.token_hex(8)
        
        names = candidate_name.split(" ", 1)
        first_name = names[0]
        last_name = names[1] if len(names) > 1 else ""
        
        new_user = User(
            username=username,
            email=candidate_email,
            role=UserRole.CANDIDATE,
            hashed_password=hashed_password,
        )
        
        profile = CandidateProfile(
            first_name=first_name,
            last_name=last_name,
            resume_id=resume_id,
            skills=[]
        )
        new_user.candidate_profile = profile
        
        uow.users.create_user(new_user)
        # Flush to get the ID for response
        await uow.flush()
        
        await email_service.send_candidate_password_email(candidate_email, candidate_name, password)
        
        return CandidateResponse(
            id=str(new_user.id),
            username=new_user.username,
            email=new_user.email,
            is_active=new_user.is_active,
            login_disabled=new_user.login_disabled,
            created_at=new_user.created_at,
            job_description=job_description 
        )

@router.get("/admin/candidates", response_model=List[CandidateResponse])
async def get_all_candidates(
    current_admin: User = Depends(get_current_admin),
    session: AsyncSession = Depends(get_db_session)
):
    async with UnitOfWork(session) as uow:
        # We need a robust way to list specifically candidates
        result = await session.execute(select(User).where(User.role == UserRole.CANDIDATE))
        users = result.scalars().all()
        
        candidates = []
        for u in users:
            c = CandidateResponse(
                id=str(u.id),
                username=u.username,
                email=u.email,
                is_active=u.is_active,
                login_disabled=u.login_disabled,
                created_at=u.created_at,
                job_description="Mock JD"
            )
            candidates.append(c)
        return candidates

@router.post("/admin/candidates/{candidate_id}/toggle-login")
async def toggle_candidate_login(
    candidate_id: str, 
    current_admin: User = Depends(get_current_admin),
    session: AsyncSession = Depends(get_db_session)
):
    valid_id = validate_uuid(candidate_id)
    
    async with UnitOfWork(session) as uow:
        # Direct fetch since we only need simple toggling
        user = await uow.users.get_by_id(valid_id)
        if not user:
            raise HTTPException(status_code=404, detail="Candidate not found")
            
        if user.role != UserRole.CANDIDATE:
            raise HTTPException(status_code=400, detail="User is not a candidate")
        
        new_status = not user.login_disabled
        user.login_disabled = new_status
        user.updated_at = datetime.now(timezone.utc)
        
        return {
            "message": f"Candidate login has been {'disabled' if new_status else 'enabled'}",
            "candidate_id": str(user.id),
            "email": user.email,
            "login_disabled": new_status
        }
